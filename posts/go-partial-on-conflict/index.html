<!doctype html><html lang=en><head><title>Writing ON CONFLICT Clauses on Partial Indexes using GORM :: kubuzetto's blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A short tale of caution on keeping your dependencies up-to-date."><meta name=keywords content="go,gorm,postgres,sql"><meta name=robots content="noodp"><link rel=canonical href=/posts/go-partial-on-conflict/><link rel=stylesheet href=/styles.css><link rel="shortcut icon" href=/img/theme-colors/orange.png><link rel=apple-touch-icon href=/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Writing ON CONFLICT Clauses on Partial Indexes using GORM"><meta property="og:description" content="A short tale of caution on keeping your dependencies up-to-date."><meta property="og:url" content="/posts/go-partial-on-conflict/"><meta property="og:site_name" content="kubuzetto's blog"><meta property="og:image" content="/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-08-21 02:35:04 +0300 +0300"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>kubuzetto's blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;â–¾</li><li><ul class=menu__dropdown><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/pages/about/>About</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/pages/about/>About</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/posts/go-partial-on-conflict/>Writing ON CONFLICT Clauses on Partial Indexes using GORM</a></h1><div class=post-meta><time class=post-date>2025-08-21</time></div><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#problem>Problem</a></li><li><a href=#why-did-i-write-a-blog-post-on-this>Why did I write a blog post on this?</a></li></ul></nav></div><div class=post-content><div><h2 id=introduction>Introduction<a href=#introduction class=hanchor arialabel=Anchor>&#8983;</a></h2><p>PostgreSQL&rsquo;s <code>ON CONFLICT</code> clause is a useful construct that allows you to
handle cases where an insertion may violate a uniqueness constraint. It is
not standard SQL syntax, but an extension, like SQLite&rsquo;s <code>INSERT OR REPLACE</code>.</p><p>Let&rsquo;s say we have a table named <code>tasks</code> like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>not</span> <span style=color:#66d9ef>exists</span> tasks
</span></span><span style=display:flex><span>(
</span></span><span style=display:flex><span>    account_id integer <span style=color:#66d9ef>not</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    task_name  text    <span style=color:#66d9ef>not</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    task_desc  text    <span style=color:#66d9ef>not</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#75715e>-- Yes, I prefer lowercase SQL. Sue me
</span></span></span></code></pre></div><p>Say we want tasks to have unique names for each account. Let&rsquo;s define a unique index for it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>unique</span> <span style=color:#66d9ef>index</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>not</span> <span style=color:#66d9ef>exists</span> unq_tasks_index
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>on</span> tasks (account_id, task_name);
</span></span></code></pre></div><p>Let&rsquo;s say we need to perform an upsert operation on this table.
Maybe we have a wacky endpoint that either rewrites the description of
an existing task, or creates one anew. I don&rsquo;t know; I just want to get to the point.</p><p>To <strong>upsert</strong>; we can write the following query:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> tasks (account_id, task_name, task_desc)
</span></span><span style=display:flex><span><span style=color:#66d9ef>values</span> (<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;test task&#39;</span>, <span style=color:#e6db74>&#39;This is a test task&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>on</span> conflict (account_id, task_name)
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span> <span style=color:#66d9ef>update</span> <span style=color:#66d9ef>set</span> task_desc<span style=color:#f92672>=</span>excluded.task_desc;
</span></span></code></pre></div><p>This does one of two things, atomically:</p><ul><li>If an entry with the same <code>(account_id, task_name)</code> pair exists,
it simply <em>updates</em> the <code>task_desc</code> field.</li><li>If such an entry does not exist, it <em>inserts</em> it.</li></ul><p><code>excluded</code> is a keyword here; referring to the row that is newly being inserted.
(Perhaps <code>proposed</code> or <code>candidate</code> would be better names, but what do I know?)</p><blockquote><p>We can also insert multiple rows this way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> tasks (account_id, task_name, task_desc)
</span></span><span style=display:flex><span><span style=color:#66d9ef>values</span> (<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;test task&#39;</span>, <span style=color:#e6db74>&#39;This is a test task&#39;</span>),
</span></span><span style=display:flex><span>       (<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;test task 2&#39;</span>, <span style=color:#e6db74>&#39;Another task&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>on</span> conflict (account_id, task_name)
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span> <span style=color:#66d9ef>update</span> <span style=color:#66d9ef>set</span> task_desc<span style=color:#f92672>=</span>excluded.task_desc;
</span></span></code></pre></div><p>But there is an important edge case here! If the proposed rows conflict <em><strong>with each other</strong></em>, then you get the following error:</p><pre tabindex=0><code>[21000] ERROR: ON CONFLICT DO UPDATE command cannot affect row a second time
</code></pre><p>This behavior is documented <a href=https://www.postgresql.org/docs/current/sql-insert.html#SQL-ON-CONFLICT>here</a>:</p><pre tabindex=0><code>INSERT with an ON CONFLICT DO UPDATE clause is a &#34;deterministic&#34; statement.
This means that the command will not be allowed to affect any single existing
row more than once; a cardinality violation error will be raised when this 
situation arises.
</code></pre><p>Be careful if you&rsquo;re using this variant!</p></blockquote><p>Raw query is fine and all, but if we wanted to achieve the same behavior using GORM,
we can use <code>clauses.OnConflict</code> <a href=https://gorm.io/docs/create.html#Upsert-On-Conflict>like this</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Task</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>AccountID</span> <span style=color:#66d9ef>uint</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>TaskName</span>, <span style=color:#a6e22e>TaskDesc</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>task</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Task</span>{<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;test task&#34;</span>, <span style=color:#e6db74>&#34;This is a test task&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Clauses</span>(<span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>OnConflict</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Columns</span>: []<span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>Column</span>{{<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;account_id&#34;</span>}, {<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;task_name&#34;</span>}},
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DoUpdates</span>: <span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>AssignmentColumns</span>([]<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;task_desc&#34;</span>}),
</span></span><span style=display:flex><span>}).<span style=color:#a6e22e>Create</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>task</span>)
</span></span></code></pre></div><h2 id=problem>Problem<a href=#problem class=hanchor arialabel=Anchor>&#8983;</a></h2><p>What if we wanted soft-delete functionality for this table? We&rsquo;d need a column like <code>is_deleted</code>, or <code>deleted_at</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>table</span> tasks
</span></span><span style=display:flex><span>(
</span></span><span style=display:flex><span>    account_id integer <span style=color:#66d9ef>not</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    task_name  text    <span style=color:#66d9ef>not</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    task_desc  text    <span style=color:#66d9ef>not</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>-- added
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    deleted_at <span style=color:#66d9ef>timestamp</span> <span style=color:#66d9ef>with</span> time <span style=color:#66d9ef>zone</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>That&rsquo;s easy, but now our unique index does not make sense.
Now if we create a task named <code>abc</code>, delete it, then create a new one;
the newly created entry will conflict with the deleted one!
We should keep that from happening using a <em>partial index</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>unique</span> <span style=color:#66d9ef>index</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>not</span> <span style=color:#66d9ef>exists</span> unq_tasks_index
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>on</span> tasks (account_id, task_name)
</span></span><span style=display:flex><span>    <span style=color:#75715e>-- added
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>where</span> deleted_at <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span>;
</span></span></code></pre></div><p>Now uniqueness checks are performed only among non-deleted rows. Cool.</p><p>We should also modify our query. We add the <code>deleted_at</code> column to
the column list, corresponding values, and the update set:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> tasks (account_id, task_name, task_desc, deleted_at)
</span></span><span style=display:flex><span><span style=color:#66d9ef>values</span> (<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;test task&#39;</span>, <span style=color:#e6db74>&#39;This is a test task&#39;</span>, <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>on</span> conflict (account_id, task_name)
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span> <span style=color:#66d9ef>update</span> <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>    task_desc<span style=color:#f92672>=</span>excluded.task_desc,
</span></span><span style=display:flex><span>    deleted_at<span style=color:#f92672>=</span>excluded.deleted_at;
</span></span></code></pre></div><p>After this, converting it to GORM is trivi-</p><pre tabindex=0><code>[42P10] ERROR: there is no unique or exclusion constraint matching the ON CONFLICT specification
</code></pre><p>Oh. We have an error. Of course.</p><p>Now that we have a <em>partial</em> index; our conflict condition does not match an existing index.</p><p>Fortunately, we can pass a <code>where</code> clause as an
<a href=https://www.postgresql.org/docs/current/sql-insert.html#SQL-ON-CONFLICT>index predicate</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> tasks (account_id, task_name, task_desc, deleted_at)
</span></span><span style=display:flex><span><span style=color:#66d9ef>values</span> (<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;test task&#39;</span>, <span style=color:#e6db74>&#39;This is a test task&#39;</span>, <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>on</span> conflict (account_id, task_name)
</span></span><span style=display:flex><span>    <span style=color:#75715e>-- added
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>where</span> deleted_at <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span> <span style=color:#66d9ef>update</span> <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>    task_desc<span style=color:#f92672>=</span>excluded.task_desc,
</span></span><span style=display:flex><span>    deleted_at<span style=color:#f92672>=</span>excluded.deleted_at;
</span></span></code></pre></div><p>Then the partial index is properly inferred, and the query works as intended.</p><p>Converting this to GORM <em>is</em> trivial:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Task</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>AccountID</span> <span style=color:#66d9ef>uint</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>TaskName</span>, <span style=color:#a6e22e>TaskDesc</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DeletedAt</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>task</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Task</span>{<span style=color:#a6e22e>AccountID</span>: <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>TaskName</span>: <span style=color:#e6db74>&#34;test task&#34;</span>, <span style=color:#a6e22e>TaskDesc</span>: <span style=color:#e6db74>&#34;This is a test task&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Clauses</span>(<span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>OnConflict</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Columns</span>: []<span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>Column</span>{{<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;account_id&#34;</span>}, {<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;task_name&#34;</span>}},
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DoUpdates</span>: <span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>AssignmentColumns</span>([]<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;task_desc&#34;</span>}),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// added
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>TargetWhere</span>: <span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>Where</span>{<span style=color:#a6e22e>Exprs</span>: []<span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>Expression</span>{
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>Eq</span>{<span style=color:#a6e22e>Column</span>: <span style=color:#e6db74>&#34;deleted_at&#34;</span>, <span style=color:#a6e22e>Value</span>: <span style=color:#66d9ef>nil</span>},
</span></span><span style=display:flex><span>    }},
</span></span><span style=display:flex><span>}).<span style=color:#a6e22e>Create</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>task</span>)
</span></span></code></pre></div><p>The <code>TargetWhere</code> field of <code>clauses.OnConflict</code> lets us provide the index predicate here.</p><blockquote><p>Do not confuse it with the <code>Where</code> field, which is a regular
<code>WHERE</code> that goes at the <em>end</em> of the clause.</p></blockquote><p>We can perform atomic upsert operations on a table with a partial index using GORM like this.</p><h2 id=why-did-i-write-a-blog-post-on-this>Why did I write a blog post on this?<a href=#why-did-i-write-a-blog-post-on-this class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Because the <code>TargetWhere</code> field does not exist in GORM version v1.21.3, which is what I had to use in a
project due to, uhh, reasons. Mind that the latest version is > v1.30; and the problem has long been
addressed with <a href=https://github.com/go-gorm/gorm/commit/dd8bf88eb9abdac71a290222ee2f70cf293c662b>this commit</a>,
<strong>four years ago</strong> (The joys of enterprise software).</p><p>I ended up writing a temporary duplicate for the <code>OnConflict</code> clause like this,
along with a TODO message strongly suggesting we update our dependencies.</p><p>Note that I used the same field names as <code>clauses.OnConflict</code> in v1.30.1,
so I can simply replace this with the original clause once our dependency is upgraded.
This version is also missing other unused fields, and some value checks etc. for brevity:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PartialOnConflict</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Columns</span>     []<span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>Column</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>TargetWhere</span> <span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>Where</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DoUpdates</span>   <span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>Set</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>PartialOnConflict</span>) <span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>b</span> <span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>Builder</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>WriteByte</span>(<span style=color:#e6db74>&#39;(&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Columns</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>WriteByte</span>(<span style=color:#e6db74>&#39;,&#39;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>WriteQuoted</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34;) WHERE &#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>TargetWhere</span>.<span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#e6db74>&#34; DO UPDATE SET &#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>DoUpdates</span>.<span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>PartialOnConflict</span>) <span style=color:#a6e22e>Name</span>() <span style=color:#66d9ef>string</span> { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;ON CONFLICT&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>PartialOnConflict</span>) <span style=color:#a6e22e>MergeClause</span>(<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>clause</span>.<span style=color:#a6e22e>Clause</span>) { <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Expression</span> = <span style=color:#a6e22e>c</span> }
</span></span></code></pre></div><p>As far as I could see, the issue and the corresponding fix in GORM was not explicitly documented
in the changelog, but I might have missed it too. If you found yourself in a similar situation,
I hope this blog post explains the situation, and encourages you to keep your dependencies up-to-date.</p><p>The rest of you, I wish you productive days. Go now.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=/posts/go-mongo-fixtures/><span class=button__text>Implementing MongoDB Test Fixtures in Go</span>
<span class=button__icon>â†’</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>Â© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>