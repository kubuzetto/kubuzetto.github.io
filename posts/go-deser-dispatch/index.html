<!doctype html><html lang=en><head><title>Automatic Go Union Deserialization Dispatch with Tags :: kubuzetto's blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Here is another quick use case for the field offset trick we pulled in the previous posts."><meta name=keywords content="go,http,reflection"><meta name=robots content="noodp"><link rel=canonical href=/posts/go-deser-dispatch/><link rel=stylesheet href=/styles.css><link rel="shortcut icon" href=/img/theme-colors/orange.png><link rel=apple-touch-icon href=/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Automatic Go Union Deserialization Dispatch with Tags"><meta property="og:description" content="Here is another quick use case for the field offset trick we pulled in the previous posts."><meta property="og:url" content="/posts/go-deser-dispatch/"><meta property="og:site_name" content="kubuzetto's blog"><meta property="og:image" content="/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-06-02 00:27:23 +0300 +0300"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>kubuzetto's blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/pages/about/>About</a></li><li><a href=/tags>Tags</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=/pages/about/>About</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/posts/go-deser-dispatch/>Automatic Go Union Deserialization Dispatch with Tags</a></h1><div class=post-meta><time class=post-date>2025-06-02</time></div><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#the-problem>The problem</a></li><li><a href=#enter-boilerplate>Enter boilerplate</a><ul><li><a href=#a-small-aside>A small aside</a></li></ul></li><li><a href=#using-reflection>Using reflection</a></li><li><a href=#here-it-comes>Here it comes</a></li><li><a href=#theres-more>There&rsquo;s more</a></li></ul></nav></div><div class=post-content><div><h2 id=introduction>Introduction<a href=#introduction class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Ok, this will be a short one.</p><p>In the <a href=/posts/go-axum-handlers-pt2/>previous posts</a>; we tried to reduce endpoint handler boilerplate in Go
by imitating the Axum magic functions. This post is <em><strong>not</strong></em> about that, but I think one of the tricks we
pulled there may have another use case.</p><p>If you&rsquo;ll recall, we iterated through two separate solutions to the endpoint problem, where in the latter one
we used struct fields to represent endpoint parameters.
To initialize those fields into <code>any</code> references that internally retain type info, we used <code>reflect.NewAt</code>
with the field offset like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>fieldPtr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>structPtr</span>), <span style=color:#a6e22e>fieldOffset</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>fieldRef</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>NewAt</span>(<span style=color:#a6e22e>fieldType</span>, <span style=color:#a6e22e>fieldPtr</span>).<span style=color:#a6e22e>Interface</span>()
</span></span></code></pre></div><p>Since we get <code>fieldOffset</code> and <code>fieldType</code> from a <code>reflect.StructField</code> that we obtained through iterating the struct&rsquo;s
type reflectively; the offset into the struct is guaranteed to hold the field&rsquo;s type. This will be useful.</p><p>Enough recap. If you didn&rsquo;t read that post, you don&rsquo;t really have to. I&rsquo;ll go over this approach in this post anyway.</p><h2 id=the-problem>The problem<a href=#the-problem class=hanchor arialabel=Anchor>&#8983;</a></h2><p>This time, we are trying to solve another problem.</p><p>I am currently dealing with a JSON API that returns lists of different kinds of items.
The API awkwardly has a single endpoint, where the type of the returned <code>items</code> array is
discerned using a tag field (<code>type</code>). Here is what I mean.</p><p>Let&rsquo;s say that the API can return an array of either <code>Crustacean</code>s or <code>Rodent</code>s:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Crustacean</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>HasCarapace</span> <span style=color:#66d9ef>bool</span>   <span style=color:#e6db74>`json:&#34;has_carapace&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Color</span>       <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;color&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Rodent</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IsDigging</span> <span style=color:#66d9ef>bool</span> <span style=color:#e6db74>`json:&#34;is_digging&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>NumTeeth</span>  <span style=color:#66d9ef>uint</span> <span style=color:#e6db74>`json:&#34;num_teeth&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The response is either:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;gopher&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;items&#34;</span>: [
</span></span><span style=display:flex><span>    {<span style=color:#f92672>&#34;is_digging&#34;</span>: <span style=color:#66d9ef>true</span>, <span style=color:#f92672>&#34;num_teeth&#34;</span>: <span style=color:#ae81ff>4</span>},
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>...</span>
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>or:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;crab&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;items&#34;</span>: [
</span></span><span style=display:flex><span>    {<span style=color:#f92672>&#34;has_carapace&#34;</span>: <span style=color:#66d9ef>true</span>, <span style=color:#f92672>&#34;color&#34;</span>: <span style=color:#e6db74>&#34;red&#34;</span>},
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>...</span>
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=enter-boilerplate>Enter boilerplate<a href=#enter-boilerplate class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The first issue is to represent this with a Go struct. Since we don&rsquo;t really have union types in Go,
we have to awkwardly write a sum type to handle all possible responses:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Items</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ItemType</span>    <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Depending on the item type; only one of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// these arrays is potentially non-empty.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Crustaceans</span> []<span style=color:#a6e22e>Crustacean</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Rodents</span>     []<span style=color:#a6e22e>Rodent</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since all item types are returned in the same <code>items</code> field; we must write a custom unmarshal function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>items</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Items</span>) <span style=color:#a6e22e>UnmarshalJSON</span>(<span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// inlined data type to deserialize the type field.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// also extract the items array&#39;s bytes; but as raw msg
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Type</span>  <span style=color:#66d9ef>string</span>          <span style=color:#e6db74>`json:&#34;type&#34;`</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Items</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>RawMessage</span> <span style=color:#e6db74>`json:&#34;items&#34;`</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// first deserialize the general shape of the message.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// this will give us the message type field. use it to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// dispatch to separate unmarshal calls.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>b</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>items</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// set the item type field, then dispatch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>items</span>.<span style=color:#a6e22e>ItemType</span> = <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Type</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Type</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;crab&#34;</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e>// type: crab unmarshals items into the Crustaceans array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Items</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>items</span>.<span style=color:#a6e22e>Crustaceans</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;gopher&#34;</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e>// type: gopher unmarshals items into the Rodents array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Items</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>items</span>.<span style=color:#a6e22e>Rodents</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;unknown item type &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Type</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I hope this is straightforward:</p><ol><li>First we parse the json to identify the <code>type</code> field. During this, we also get the value of the <code>items</code> key as
a raw byte array using <code>json.RawMessage</code>.</li><li>Using the value of the <code>type</code> field, we employ a switch-case to deserialize this <code>RawMessage</code> differently.
If <code>type=="crab"</code>, we treat the bytes as <code>[]Crustacean</code>, if <code>type=="gopher"</code> we deserialize them as <code>[]Rodent</code>.</li></ol><p>This does work; but there is something about that switch-case that bothers me. In the actual scenario, I&rsquo;m dealing with
more than 10 item types; so the switch-case becomes quite large.</p><p>Also, consider what we should do to add a new item type here, like a <code>Camel</code>:</p><ol><li>Add a new <code>Camels []Camel</code> field to the <code>Items</code> struct.</li><li>Add a new <code>case "camel":</code> case to the unmarshal code.</li><li>While copy-pasting code, make sure you change the <code>Unmarshal</code> target to <code>&amp;items.Camels</code>.</li></ol><p>Omitting step #2, or making a mistake in #3 will not cause compilation errors. In the worst possible case;
two subtypes can be close enough that the actual deserialization also does not fail; causing the wrong logic
to be executed eventually.</p><h3 id=a-small-aside>A small aside<a href=#a-small-aside class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Also consider the usage of this type. We end up with another switch-case while using it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>VisitItems</span>(<span style=color:#a6e22e>items</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Items</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>items</span>.<span style=color:#a6e22e>ItemType</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;crab&#34;</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>items</span>.<span style=color:#a6e22e>Crustaceans</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>handleCrustacean</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;gopher&#34;</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>items</span>.<span style=color:#a6e22e>Rodents</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>handleRodent</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Although we can do a little evil here and abuse the fact that only one of these arrays have elements, like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>VisitItems</span>(<span style=color:#a6e22e>items</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Items</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>items</span>.<span style=color:#a6e22e>Crustaceans</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handleCrustacean</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>items</span>.<span style=color:#a6e22e>Rodents</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handleRodent</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This way we won&rsquo;t actually need to have an <code>ItemType</code> field in <code>Items</code>. I&rsquo;m not advocating you to do this, though;
depending on your case the latter may be significantly less readable and/or brittle.</p><p>Anyway, where were we?</p><h2 id=using-reflection>Using reflection<a href=#using-reflection class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The problem is that we are making highly coupled changes in two locations at once.</p><p>Wouldn&rsquo;t it be (slightly) better if we could just do this?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Items</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Crustaceans</span> []<span style=color:#a6e22e>Crustacean</span> <span style=color:#e6db74>`item:&#34;crab&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Rodents</span>     []<span style=color:#a6e22e>Rodent</span>     <span style=color:#e6db74>`item:&#34;gopher&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>items</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Items</span>) <span style=color:#a6e22e>UnmarshalJSON</span>(<span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Type</span>  <span style=color:#66d9ef>string</span>          <span style=color:#e6db74>`json:&#34;type&#34;`</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Items</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>RawMessage</span> <span style=color:#e6db74>`json:&#34;items&#34;`</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>b</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// which field should we read into? determine using t.Type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fieldInfo</span>, <span style=color:#a6e22e>isKnownType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>itemFields</span>[<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Type</span>]; <span style=color:#a6e22e>isKnownType</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// get a reference to the relevant field as `any`, and unmarshal into it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Items</span>, <span style=color:#a6e22e>fieldInfo</span>.<span style=color:#a6e22e>getRef</span>(<span style=color:#a6e22e>items</span>))
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;unknown item type &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Type</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note how we associated each field&rsquo;s type name with it using a struct tag named <code>item</code>.
We can populate the <code>itemFields</code> map using a little reflection as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// populate this only once during module load
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>itemFields</span> = <span style=color:#a6e22e>structFieldGetter</span>[<span style=color:#a6e22e>Items</span>](<span style=color:#e6db74>&#34;item&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>structFieldGetter</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>](<span style=color:#a6e22e>tagName</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>FieldInfo</span>[<span style=color:#a6e22e>T</span>] {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fields</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>FieldInfo</span>[<span style=color:#a6e22e>T</span>])
</span></span><span style=display:flex><span>	<span style=color:#75715e>// first, obtain type for the struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>structType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeFor</span>[<span style=color:#a6e22e>T</span>]()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// iterate all struct fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>idx</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>structType</span>.<span style=color:#a6e22e>NumField</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>structField</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structType</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>idx</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// if the field has the given tag
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fieldName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>structField</span>.<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>tagName</span>); <span style=color:#a6e22e>fieldName</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// save its offset and type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>fields</span>[<span style=color:#a6e22e>fieldName</span>] = <span style=color:#a6e22e>FieldInfo</span>[<span style=color:#a6e22e>T</span>]{
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>fieldOffset</span>: <span style=color:#a6e22e>structField</span>.<span style=color:#a6e22e>Offset</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>fieldType</span>:   <span style=color:#a6e22e>structField</span>.<span style=color:#a6e22e>Type</span>,
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fields</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>FieldInfo</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>] <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 0-sized phantom data for type safety
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_</span> [<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fieldOffset</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fieldType</span>   <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// get a reference to the field of the struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span> <span style=color:#a6e22e>FieldInfo</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#a6e22e>getRef</span>(<span style=color:#a6e22e>structRef</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>any</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// todo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Ok, we create a map from the specified item type string to a <code>FieldInfo</code> struct.
<code>FieldInfo</code> records the type and offset of each eligible field, which we will later use to get
a reference to that field when we have an <code>Items</code> struct.</p><blockquote><p>The &ldquo;0-sized phantom data&rdquo; there is needed, because without that <code>FieldInfo[T]</code> and <code>FieldInfo[Y]</code>
would have the same layout for different <code>T</code> and <code>Y</code>, and the compiler wouldn&rsquo;t prevent casts from
one to the other. We need that <code>T</code> to not change so that we can guarantee <code>getRef</code>&rsquo;s type safety.</p></blockquote><h2 id=here-it-comes>Here it comes<a href=#here-it-comes class=hanchor arialabel=Anchor>&#8983;</a></h2><p>To implement <code>getRef</code>, we will use the trick we described earlier.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span> <span style=color:#a6e22e>FieldInfo</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#a6e22e>getRef</span>(<span style=color:#a6e22e>structRef</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>any</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// convert to unsafe pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>structPtr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>structRef</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// trivial pointer arithmetic to get the field&#39;s address
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fieldPtr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>structPtr</span>, <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>fieldOffset</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// instantiate the field type at the given address; return as an interface
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>NewAt</span>(<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>fieldType</span>, <span style=color:#a6e22e>fieldPtr</span>).<span style=color:#a6e22e>Interface</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since we obtained the field info by iterating <code>T</code>, and also received a <code>*T</code> in <code>getRef</code>; we ensure that the
given offset will have the given type. Then we can safely use <code>reflect.NewAt</code> to instantiate the field at the
given address. This gives us a valid <code>reflect.Value</code>, which we then can convert to <code>any</code> using <code>.Interface()</code>.
Then the unmarshaller code can use it as a destination for the <code>items</code> array&rsquo;s bytes. Voila!</p><p>Once again, the reflection code that walks the struct&rsquo;s fields runs only once at the start of the program.
Some of the reflection does take place during <code>getRef</code>, but <code>json.Unmarshal</code> already uses reflection
internally, so it&rsquo;s not like we are introducing RTTI where it wasn&rsquo;t previously needed.</p><p>With this, adding a new item type requires updates in only one site:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Items</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Crustaceans</span> []<span style=color:#a6e22e>Crustacean</span> <span style=color:#e6db74>`item:&#34;crab&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Rodents</span>     []<span style=color:#a6e22e>Rodent</span>     <span style=color:#e6db74>`item:&#34;gopher&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Camels</span>      []<span style=color:#a6e22e>Camel</span>      <span style=color:#e6db74>`item:&#34;camel&#34;`</span> <span style=color:#75715e>// &lt;----
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>And the unmarshaller will automatically start to handle camels as well.</p><h2 id=theres-more>There&rsquo;s more<a href=#theres-more class=hanchor arialabel=Anchor>&#8983;</a></h2><p>This approach also has another (albeit minor) advantage.</p><p>We could have simply put <code>getRef</code> directly into the map as an anonymous function, but we chose to create
a <code>FieldInfo</code> type where <code>getRef</code> was a member function. This is because fields can carry more info, which
we can now store in the <code>FieldInfo</code> struct!</p><p>I&rsquo;ll give you an example.</p><p>Remember the API I was reading from? Well, that API has pagination. Since each item can have wildly different sizes,
it makes sense to have a different page size for different item types. For example, I can easily fetch 1000
crustacean rows at once, but camels have a &ldquo;comment&rdquo; field that have paragraphs of text; so maybe I shouldn&rsquo;t
exceed 100 entries in one page.</p><p>Let&rsquo;s model that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Items</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Crustaceans</span> []<span style=color:#a6e22e>Crustacean</span> <span style=color:#e6db74>`item:&#34;crab,page_size=1000&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Rodents</span>     []<span style=color:#a6e22e>Rodent</span>     <span style=color:#e6db74>`item:&#34;gopher,page_size=1000&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Camels</span>      []<span style=color:#a6e22e>Camel</span>      <span style=color:#e6db74>`item:&#34;camel,page_size=100&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now all we have to do is parse the tag text to obtain this field. I&rsquo;ll omit that code because it&rsquo;s
trivial and beside the point; but as a result we add an <code>PageSize</code> field to the <code>FieldInfo</code> struct:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>FieldInfo</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>] <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span> [<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fieldOffset</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fieldType</span>   <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Type</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>PageSize</span> <span style=color:#66d9ef>uint</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>If you&rsquo;d like to keep this struct general-purpose, maybe an <code>Attr map[string]any</code> field may be better.
It&rsquo;s late here, so instead I want to get to the point and go to sleep.</p></blockquote><p>Then we can get the page size for each item type as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>pageSize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>itemFields</span>[<span style=color:#a6e22e>itemType</span>].<span style=color:#a6e22e>PageSize</span>
</span></span></code></pre></div><p>The alternative would have been keeping a separate map like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pageSizes</span> = <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>uint</span>{
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;crab&#34;</span>: <span style=color:#ae81ff>1000</span>, <span style=color:#e6db74>&#34;gopher&#34;</span>: <span style=color:#ae81ff>1000</span>, <span style=color:#e6db74>&#34;camel&#34;</span>: <span style=color:#ae81ff>100</span>, <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pageSize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pageSizes</span>[<span style=color:#a6e22e>itemType</span>]
</span></span></code></pre></div><p>which we would have to maintain and make sure we didn&rsquo;t miss any of the keys.</p><p>Anyway, this is all I have for today. Go now.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/go-mongo-fixtures/><span class=button__icon>←</span>
<span class=button__text>Implementing MongoDB Test Fixtures in Go</span>
</a></span><span class="button next"><a href=/posts/go-axum-handlers-pt2/><span class=button__text>Axum-style Magic Handler Functions in Go, Part 2</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/mirus-ua/hugo-theme-re-terminal target=_blank>Theme</a> made by <a href=https://github.com/mirus-ua target=_blank>Mirus</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>